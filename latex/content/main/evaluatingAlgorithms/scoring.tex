\subsection{Scoring based algorithms}\label{sec:scoring}
    In the previous sections, we looked at and evaluated many algorithms that either operated on their own or delegated to a fallback in case of insufficient data availability. Especially the latter approach yielded promising results by using domain-specific inputs. However, in all cases, only a single algorithm was choosing on its own (even if that choice would be to delegate). The algorithms never interacted with another.
    
    This section will be looking at the potential performance gains achievable by combining different algorithms' decision-making process using a scoring system. Each scoring algorithm will assign a numeric score to a pipeline. The points from all algorithms will then be summed up, and the artefact with the highest one will be removed. As opposed to the layered approach, each input will partake in the decision-making process instead of deciding between inputs and using just one. To begin with, we have to define the scoring processes.
    
    \paragraph{Status} As the pipeline status input yielded promising results in the previous section, we will use it as one input for our scoring system. We will be assigning four different scores to each of the four possible (and relevant) states of a pipeline: Failed, successful, cancelled, or running.
    
    \paragraph{Merge} Another algorithm that proved itself in prior experiments was based on the merge status of a pipelines associated branch. For this reason, we will be using this input as well. When a pipelines branch has been merged it will be assigned a preconfigured score, otherwise zero. It should be noted that this simple approach discards the order in which pipelines have been merged. Future research might want to consider this information to develop a more sophisticated scoring approach.
    
    \paragraph{Age} Finally, we will be taking the age of the artefact into account. This can be done in two different ways. Either by defining a cutoff age after which a fixed score will be applied or feeding the age into a function (e.g. $x^2$). While the first one requires the definition of a cutoff age, it is relatively simple in design and operates within fixed bounds. The second one requires more care when designing a function to use. By outputting scores that are too large, the algorithm would overshadow others. Too small scores will result in it not influencing the results. To overcome this issue, we will combine the two approaches and use the defined cutoff age as a maximum. All values between zero and this age will be interpolated using an easing function in the range [0;1]. The resulting score will be multiplied by a fixed amount. For interpolation, we will be using a cosine based function shown in equation \ref{eq:age-easing}, which eases both in and out\footnote{This function has been chosen due to its relative simplicity â€” however, it is expected that this choice does not make any significant impact in this context as other factors play a stronger role.}.
    
    \begin{equation}\label{eq:age-easing}
        y=-0.5\cdot\left(\cos\left(\pi\ \cdot\ x\right)-1\right)
    \end{equation}
    
    While more inputs could be added, the number of parameters to define is already growing rather large. To keep these manageable, we will keep the scoring algorithm count at three. This is presumably the biggest drawback to this type of algorithm; the parameter space's vastness makes choosing optimal values a problematic endeavour. Since finding the best parameters warrants an entire dedicated research paper, we have picked values based on previous chapters' experience and using basic manual gradient-based optimisation with a bisecting search pattern. While this approach is far from ideal or reproducible, it still revealed compelling results. 
    
    \colfig{image/graphs/lineplot-score}{Performance of scoring algorithms}{fig:lineplot-scoring}
    
    The comparison against previous best performers in figure \ref{fig:lineplot-scoring} reveals that the scoring-based algorithm performs similarly to the other contenders, depending on the simulation progress. Overall, it is on-par with FIFO and MERGED and outperformed STATUS at the end of the simulation.
    
    Even though the parameters have not been optimised properly, this shows that there is potential in a shared approach that utilises different inputs simultaneously. For this reason, it is recommended to further investigate the parameter optimisation problem and other potential inputs to this algorithm.
